{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 Free software: MIT license Documentation: https://zillionare.github.io/cfg4py A python config module that: Adaptive deployment (default, dev, test, production) support Cascading configuration (central vs local) support Auto-complete Templates (logging, database, cache, message queue,...) Environment variables macro support Enable logging in one line Built on top of yaml Features \u00b6 It's common to see that you have different settings for development machine, test machine and production site. They share many common settings, but a few of them has to be different. For example, developers should connect to local database server when performing unittest, and tester should connect to their own database server. All these servers should be deployed separately and no data should be messed up. Cfg4Py has perfect solution supporting for this: adaptive deployment environment support. Adaptive Deployment Environment Support \u00b6 In any serious projects, your application may run at both development, testing and production site. Except for effort of copying similar settings here and there, sometimes we'll mess up with development environment and production site. Once this happen, it could result in very serious consequence. To solve this, Cfg4Py developed a mechanism, that you provide different sets for configurations: dev for development machine, test for testing environment and production for production site, and all common settings are put into a file called defaults . cfg4py module knows which environment it's running on by looking up environment variable cfg4py_server_role . It should be one of DEV , TEST and PRODUCTION . If nothing found, it means setup is not finished, and Cfg4Py will refuse to work. If the environment is set, then Cfg4Py will read settings from defaults set, then apply update from either of DEV , TEST and PRODUCTION set, according to the environment the application is running on. Important Since 0.9.0, cfg4py can still work if cfg4py_server_role is not set, when it work at non-strict mode. Cascading design \u00b6 Assuming you have a bunch of severs for load-balance, which usually share same configurations. So you'd like put the configurations on a central repository, which could be a redis server or a relational database. Once you update configuration settings at central repository, you update configurations for all servers. But somehow for troubleshooting or maintenance purpose, you'd like some machines could have its own settings at a particular moment. This is how Cfg4Py solves the problem: Configure your application general settings at remote service, then implement a RemoteConfigFetcher (Cfg4Py has already implemented one, that read settings from redis), which pull configuration from remote serivce periodically. Change the settings on local machine, after the period you've set, these changes are popluated to all machines. Auto-complete \u00b6 auto-complete With other python config module, you have to remember all the configuration keys, and refer to each settings by something like cfg \"services\" [\"host\"] and etc. Keys are hard to rememb, prone to typo, and way too much tedious. When cfg4py load raw settigns from yaml file, it'll compile all the settings into a Python class, then Cfg4Py let you access your settings by attributes. Compares the two ways to access configure item: 1 cfg [ \"services\" ][ \"redis\" ][ \"host\" ] vs: 1 cfg . services . redis . host Apparently the latter is the better. And, if you trigger a build against your configurations, it'll generate a python class file. After you import this file (named 'schema.py') into your project, then you can enjoy code auto-complete! Templates \u00b6 It's hard to remember how to configure log, database, cache and etc, so cfg4py provide templates. Just run cfg4py scaffold, follow the tips then you're done. scaffold Environment variables macro \u00b6 The best way to keep secret, is never share them. If you put account/password files, and these files may be leak to the public. For example, push to github by accident. With cfg4py, you can set these secret as environment variables, then use marco in config files. For example, if you have the following in defaults.yaml (any other files will do too): 1 2 postgres: dsn: postgres://${postgres_account}:${postgres_password}@localhost then cfg4py will lookup postgres_account, postgres_password from environment variables and make replacement. Enable logging with one line \u00b6 with one line, you can enable file-rotating logging: 1 cfg . enable_logging ( level , filename = None ) Apply configuration change on-the-fly \u00b6 Cfg4Py provides mechanism to automatically apply configuration changes without restart your application. For local files configuration change, it may take effect immediately. For remote config change, it take effect up to refresh_interval settings. On top of yaml \u00b6 The raw config format is backed by yaml, with macro enhancement. YAML is the best for configurations. Credits \u00b6 This package was created ppw","title":"home"},{"location":"#overview","text":"Free software: MIT license Documentation: https://zillionare.github.io/cfg4py A python config module that: Adaptive deployment (default, dev, test, production) support Cascading configuration (central vs local) support Auto-complete Templates (logging, database, cache, message queue,...) Environment variables macro support Enable logging in one line Built on top of yaml","title":"Overview"},{"location":"#features","text":"It's common to see that you have different settings for development machine, test machine and production site. They share many common settings, but a few of them has to be different. For example, developers should connect to local database server when performing unittest, and tester should connect to their own database server. All these servers should be deployed separately and no data should be messed up. Cfg4Py has perfect solution supporting for this: adaptive deployment environment support.","title":"Features"},{"location":"#adaptive-deployment-environment-support","text":"In any serious projects, your application may run at both development, testing and production site. Except for effort of copying similar settings here and there, sometimes we'll mess up with development environment and production site. Once this happen, it could result in very serious consequence. To solve this, Cfg4Py developed a mechanism, that you provide different sets for configurations: dev for development machine, test for testing environment and production for production site, and all common settings are put into a file called defaults . cfg4py module knows which environment it's running on by looking up environment variable cfg4py_server_role . It should be one of DEV , TEST and PRODUCTION . If nothing found, it means setup is not finished, and Cfg4Py will refuse to work. If the environment is set, then Cfg4Py will read settings from defaults set, then apply update from either of DEV , TEST and PRODUCTION set, according to the environment the application is running on. Important Since 0.9.0, cfg4py can still work if cfg4py_server_role is not set, when it work at non-strict mode.","title":"Adaptive Deployment Environment Support"},{"location":"#cascading-design","text":"Assuming you have a bunch of severs for load-balance, which usually share same configurations. So you'd like put the configurations on a central repository, which could be a redis server or a relational database. Once you update configuration settings at central repository, you update configurations for all servers. But somehow for troubleshooting or maintenance purpose, you'd like some machines could have its own settings at a particular moment. This is how Cfg4Py solves the problem: Configure your application general settings at remote service, then implement a RemoteConfigFetcher (Cfg4Py has already implemented one, that read settings from redis), which pull configuration from remote serivce periodically. Change the settings on local machine, after the period you've set, these changes are popluated to all machines.","title":"Cascading design"},{"location":"#auto-complete","text":"auto-complete With other python config module, you have to remember all the configuration keys, and refer to each settings by something like cfg \"services\" [\"host\"] and etc. Keys are hard to rememb, prone to typo, and way too much tedious. When cfg4py load raw settigns from yaml file, it'll compile all the settings into a Python class, then Cfg4Py let you access your settings by attributes. Compares the two ways to access configure item: 1 cfg [ \"services\" ][ \"redis\" ][ \"host\" ] vs: 1 cfg . services . redis . host Apparently the latter is the better. And, if you trigger a build against your configurations, it'll generate a python class file. After you import this file (named 'schema.py') into your project, then you can enjoy code auto-complete!","title":"Auto-complete"},{"location":"#templates","text":"It's hard to remember how to configure log, database, cache and etc, so cfg4py provide templates. Just run cfg4py scaffold, follow the tips then you're done. scaffold","title":"Templates"},{"location":"#environment-variables-macro","text":"The best way to keep secret, is never share them. If you put account/password files, and these files may be leak to the public. For example, push to github by accident. With cfg4py, you can set these secret as environment variables, then use marco in config files. For example, if you have the following in defaults.yaml (any other files will do too): 1 2 postgres: dsn: postgres://${postgres_account}:${postgres_password}@localhost then cfg4py will lookup postgres_account, postgres_password from environment variables and make replacement.","title":"Environment variables macro"},{"location":"#enable-logging-with-one-line","text":"with one line, you can enable file-rotating logging: 1 cfg . enable_logging ( level , filename = None )","title":"Enable logging with one line"},{"location":"#apply-configuration-change-on-the-fly","text":"Cfg4Py provides mechanism to automatically apply configuration changes without restart your application. For local files configuration change, it may take effect immediately. For remote config change, it take effect up to refresh_interval settings.","title":"Apply configuration change on-the-fly"},{"location":"#on-top-of-yaml","text":"The raw config format is backed by yaml, with macro enhancement. YAML is the best for configurations.","title":"On top of yaml"},{"location":"#credits","text":"This package was created ppw","title":"Credits"},{"location":"api/","text":"Top-level package for Cfg4Py. cli \u00b6 Command \u00b6 Source code in cfg4py/cli.py class Command : def __init__ ( self ): self . resource_path = os . path . normpath ( os . path . join ( os . path . dirname ( __file__ ), \"resources/\" ) ) self . yaml = YAML ( typ = \"safe\" ) # default, if not specfied, is 'rt' (round-trip) self . yaml . default_flow_style = False with open ( os . path . join ( self . resource_path , \"template.yaml\" ), \"r\" , encoding = \"utf-8\" ) as f : self . templates = self . yaml . load ( f ) self . transformed = self . _transform () def build ( self , config_dir : str ): \"\"\"Compile configuration files into python script, which is used by IDE's auto-complete function Args: config_dir: The folder where your configuration files located Returns: \"\"\" if not os . path . exists ( config_dir ): print ( f \"path { config_dir } not exists\" ) sys . exit ( - 1 ) count = 0 for f in os . listdir ( config_dir ): if ( f . startswith ( \"default\" ) or f . startswith ( \"dev\" ) or f . startswith ( \"test\" ) or f . startswith ( \"production\" ) ): print ( f \"found { f } \" ) count += 1 if count > 0 : print ( f \" { count } files found in total\" ) else : print ( \"the folder contains no valid configuration files\" ) sys . exit ( - 1 ) try : init ( config_dir ) sys . path . insert ( 0 , config_dir ) from schema import Config # type: ignore # noqa output_file = f \" { os . path . join ( config_dir , 'schema' ) } \" msg = f \"Config file is built with success and saved at { output_file } \" print ( msg ) except Exception as e : # pragma: no cover logging . exception ( e ) print ( \"Config file built failure.\" ) def _choose_dest_dir ( self , dst ): if dst is None : dst = input ( \"Where should I save configuration files? \\n \" ) if os . path . exists ( dst ): for f in os . listdir ( dst ): msg = f \"The folder already contains { f } , please choose clean one.\" if f in [ \"defaults.yaml\" , \"dev.yaml\" , \"test.yaml\" , \"production.yaml\" ]: print ( msg ) return None return dst else : create = input ( \"Path not exists, create('Q' to exit)? [Y/n]\" ) if create . upper () == \"Y\" : os . makedirs ( dst , exist_ok = True ) return dst elif create . upper () == \"Q\" : sys . exit ( - 1 ) else : return None def scaffold ( self , dst : Optional [ str ]): \"\"\"Creates initial configuration files based on our choices. Args: dst: Returns: \"\"\" print ( \"Creating a configuration boilerplate:\" ) dst = self . _choose_dest_dir ( dst ) while dst is None : dst = self . _choose_dest_dir ( dst ) yaml = YAML ( typ = \"safe\" ) # default, if not specfied, is 'rt' (round-trip) with open ( os . path . join ( self . resource_path , \"template.yaml\" ), \"r\" , encoding = \"utf-8\" ) as f : templates = yaml . load ( f ) print ( \"Which flavors do you want?\" ) print ( \"-\" * 20 ) prompt = \"\"\" 0 - console + rotating file logging 10 - redis/redis-py (gh://andymccurdy/redis-py) 11 - redis/aioredis (gh://aio-libs/aioredis) 20 - mysql/PyMySQL (gh://PyMySQL/PyMySQL) 30 - postgres/asyncpg (gh://MagicStack/asyncpg) 31 - postgres/psycopg2 (gh://psycopg/psycopg2) 40 - mq/pika (gh://pika/pika) 50 - mongodb/pymongo (gh://mongodb/mongo-python-driver) \"\"\" print ( prompt ) chooses = input ( \"Please choose flavors by index, separated each by a comma(,): \\n \" ) flavors = {} mapping = { \"0\" : \"logging\" , \"1\" : \"redis\" , \"2\" : \"mysql\" , \"3\" : \"postgres\" , \"4\" : \"mq\" , \"5\" : \"mongodb\" , } for index in chooses . strip ( \" \" ) . split ( \",\" ): if index == \"0\" : flavors [ \"logging\" ] = templates [ \"logging\" ] continue try : major = mapping [ index [ 0 ]] minor = int ( index [ 1 ]) flavors [ major ] = list ( templates [ major ][ minor ] . values ())[ 0 ] except ( ValueError , KeyError ): print ( f \"Wrong index { index } , skipped.\" ) continue with open ( os . path . join ( dst , \"defaults.yaml\" ), \"w\" , encoding = \"utf-8\" ) as f : f . writelines ( \"#auto generated by Cfg4Py: https://github.com/jieyu-tech/cfg4py \\n \" ) yaml . dump ( flavors , f ) print ( f \"Cfg4Py has generated the following files under { dst } :\" ) print ( \"defaults.yaml\" ) for name in [ \"dev.yaml\" , \"test.yaml\" , \"production.yaml\" ]: with open ( os . path . join ( dst , name ), \"w\" , encoding = \"utf8\" ) as f : f . writelines ( \"#auto generated by Cfg4Py: https://github.com/jieyu-tech/cfg4py \\n \" ) print ( name ) with open ( os . path . join ( dst , \"defaults.yaml\" ), \"r\" , encoding = \"utf-8\" ) as f : print ( \"Content in defaults.yaml\" ) for line in f . readlines (): print ( line . replace ( \" \\n \" , \"\" )) def _show_supported_config ( self ): print ( \"Support the following configurations:\" ) for key in self . templates . keys (): item = self . templates . get ( key ) if isinstance ( item , dict ): print ( f \" { key } \" ) elif isinstance ( item , list ): sub_keys = [] for sub_item in item : sub_keys . append ( f \" { key } / { list ( sub_item . keys ())[ 0 ] } \" ) print ( f \" { key } : { ', ' . join ( sub_keys ) } \" ) def _transform ( self ): transformed = {} for key in self . templates : if isinstance ( self . templates [ key ], dict ): transformed [ key ] = self . templates [ key ] elif isinstance ( self . templates [ key ], list ): for item in self . templates [ key ]: item_key = list ( item . keys ())[ 0 ] transformed [ f \" { key } / { item_key } \" ] = item return transformed def hint ( self , what : str = None , usage : bool = False ): \"\"\"show a cheat sheet for configurations. for example: cfg4py hint mysql this will print how to configure PyMySQL :param what :param usage \"\"\" if what is None or ( ( what not in self . templates ) and what not in self . transformed ): return self . _show_supported_config () usage_key = f \" { what } _usage\" if usage_key in self . templates and usage : print ( \"Usage:\" , self . templates . get ( usage_key )) if what in self . templates : self . yaml . dump ( self . templates [ what ], sys . stdout ) if usage_key in self . transformed and usage : print ( \"Usage:\" , self . transformed . get ( usage_key )) if what in self . transformed : self . yaml . dump ( self . transformed [ what ], sys . stdout ) def set_server_role ( self ): print ( \"please add the following line into your .bashrc: \\n \" ) print ( f \"export { envar } =DEV \\n \" ) msg = \"You need to change DEV to TEST | PRODUCTION according to its actual role \\ accordingly\" print ( msg ) def version ( self ): from cfg4py import __version__ print ( \"Easy config module support code complete, cascading design and apative deployment\" ) print ( f \"version: { __version__ } \" ) build ( self , config_dir ) \u00b6 Compile configuration files into python script, which is used by IDE's auto-complete function Parameters: Name Type Description Default config_dir str The folder where your configuration files located required Source code in cfg4py/cli.py def build ( self , config_dir : str ): \"\"\"Compile configuration files into python script, which is used by IDE's auto-complete function Args: config_dir: The folder where your configuration files located Returns: \"\"\" if not os . path . exists ( config_dir ): print ( f \"path { config_dir } not exists\" ) sys . exit ( - 1 ) count = 0 for f in os . listdir ( config_dir ): if ( f . startswith ( \"default\" ) or f . startswith ( \"dev\" ) or f . startswith ( \"test\" ) or f . startswith ( \"production\" ) ): print ( f \"found { f } \" ) count += 1 if count > 0 : print ( f \" { count } files found in total\" ) else : print ( \"the folder contains no valid configuration files\" ) sys . exit ( - 1 ) try : init ( config_dir ) sys . path . insert ( 0 , config_dir ) from schema import Config # type: ignore # noqa output_file = f \" { os . path . join ( config_dir , 'schema' ) } \" msg = f \"Config file is built with success and saved at { output_file } \" print ( msg ) except Exception as e : # pragma: no cover logging . exception ( e ) print ( \"Config file built failure.\" ) hint ( self , what = None , usage = False ) \u00b6 show a cheat sheet for configurations. for example: cfg4py hint mysql this will print how to configure PyMySQL :param what :param usage Source code in cfg4py/cli.py def hint ( self , what : str = None , usage : bool = False ): \"\"\"show a cheat sheet for configurations. for example: cfg4py hint mysql this will print how to configure PyMySQL :param what :param usage \"\"\" if what is None or ( ( what not in self . templates ) and what not in self . transformed ): return self . _show_supported_config () usage_key = f \" { what } _usage\" if usage_key in self . templates and usage : print ( \"Usage:\" , self . templates . get ( usage_key )) if what in self . templates : self . yaml . dump ( self . templates [ what ], sys . stdout ) if usage_key in self . transformed and usage : print ( \"Usage:\" , self . transformed . get ( usage_key )) if what in self . transformed : self . yaml . dump ( self . transformed [ what ], sys . stdout ) scaffold ( self , dst ) \u00b6 Creates initial configuration files based on our choices. Parameters: Name Type Description Default dst Optional[str] required Source code in cfg4py/cli.py def scaffold ( self , dst : Optional [ str ]): \"\"\"Creates initial configuration files based on our choices. Args: dst: Returns: \"\"\" print ( \"Creating a configuration boilerplate:\" ) dst = self . _choose_dest_dir ( dst ) while dst is None : dst = self . _choose_dest_dir ( dst ) yaml = YAML ( typ = \"safe\" ) # default, if not specfied, is 'rt' (round-trip) with open ( os . path . join ( self . resource_path , \"template.yaml\" ), \"r\" , encoding = \"utf-8\" ) as f : templates = yaml . load ( f ) print ( \"Which flavors do you want?\" ) print ( \"-\" * 20 ) prompt = \"\"\" 0 - console + rotating file logging 10 - redis/redis-py (gh://andymccurdy/redis-py) 11 - redis/aioredis (gh://aio-libs/aioredis) 20 - mysql/PyMySQL (gh://PyMySQL/PyMySQL) 30 - postgres/asyncpg (gh://MagicStack/asyncpg) 31 - postgres/psycopg2 (gh://psycopg/psycopg2) 40 - mq/pika (gh://pika/pika) 50 - mongodb/pymongo (gh://mongodb/mongo-python-driver) \"\"\" print ( prompt ) chooses = input ( \"Please choose flavors by index, separated each by a comma(,): \\n \" ) flavors = {} mapping = { \"0\" : \"logging\" , \"1\" : \"redis\" , \"2\" : \"mysql\" , \"3\" : \"postgres\" , \"4\" : \"mq\" , \"5\" : \"mongodb\" , } for index in chooses . strip ( \" \" ) . split ( \",\" ): if index == \"0\" : flavors [ \"logging\" ] = templates [ \"logging\" ] continue try : major = mapping [ index [ 0 ]] minor = int ( index [ 1 ]) flavors [ major ] = list ( templates [ major ][ minor ] . values ())[ 0 ] except ( ValueError , KeyError ): print ( f \"Wrong index { index } , skipped.\" ) continue with open ( os . path . join ( dst , \"defaults.yaml\" ), \"w\" , encoding = \"utf-8\" ) as f : f . writelines ( \"#auto generated by Cfg4Py: https://github.com/jieyu-tech/cfg4py \\n \" ) yaml . dump ( flavors , f ) print ( f \"Cfg4Py has generated the following files under { dst } :\" ) print ( \"defaults.yaml\" ) for name in [ \"dev.yaml\" , \"test.yaml\" , \"production.yaml\" ]: with open ( os . path . join ( dst , name ), \"w\" , encoding = \"utf8\" ) as f : f . writelines ( \"#auto generated by Cfg4Py: https://github.com/jieyu-tech/cfg4py \\n \" ) print ( name ) with open ( os . path . join ( dst , \"defaults.yaml\" ), \"r\" , encoding = \"utf-8\" ) as f : print ( \"Content in defaults.yaml\" ) for line in f . readlines (): print ( line . replace ( \" \\n \" , \"\" )) core \u00b6 Main module. LocalConfigChangeHandler ( FileSystemEventHandler ) \u00b6 Source code in cfg4py/core.py class LocalConfigChangeHandler ( FileSystemEventHandler ): def dispatch ( self , event ): if not isinstance ( event , FileModifiedEvent ): return ext = os . path . splitext ( event . src_path ) if ext in [ \".yml\" , \".yaml\" ]: _load_from_local_file () dispatch ( self , event ) \u00b6 Dispatches events to the appropriate methods. :param event: The event object representing the file system event. :type event: :class: FileSystemEvent Source code in cfg4py/core.py def dispatch ( self , event ): if not isinstance ( event , FileModifiedEvent ): return ext = os . path . splitext ( event . src_path ) if ext in [ \".yml\" , \".yaml\" ]: _load_from_local_file () config_remote_fetcher ( fetcher , interval = 300 ) \u00b6 config a remote configuration fetcher, which will pull the settings on every refresh_interval Parameters: Name Type Description Default fetcher RemoteConfigFetcher sub class of RemoteConfigFetcher required interval int how long should cfg4py to pull the configuration from remote 300 Source code in cfg4py/core.py def config_remote_fetcher ( fetcher : RemoteConfigFetcher , interval : int = 300 ): \"\"\" config a remote configuration fetcher, which will pull the settings on every `refresh_interval` Args: fetcher: sub class of `RemoteConfigFetcher` interval: how long should cfg4py to pull the configuration from remote Returns: \"\"\" global _remote_fetcher _remote_fetcher = fetcher _scheduler . add_job ( _refresh , \"interval\" , seconds = interval ) _scheduler . start () enable_logging ( level = 20 , log_file = None , file_size = 10 , file_count = 7 ) \u00b6 Enable basic log function for the application if log_file is None, then it'll provide console logging, otherwise, the console logging is turned off, all events will be logged into the provided file. Parameters: Name Type Description Default level the log level, one of logging.DEBUG, logging.INFO, logging.WARNING, 20 log_file the absolute file path for the log. None file_size file size in MB unit 10 file_count how many backup files leaved in disk 7 Returns: Type Description None Source code in cfg4py/core.py def enable_logging ( level = logging . INFO , log_file = None , file_size = 10 , file_count = 7 ): \"\"\" Enable basic log function for the application if log_file is None, then it'll provide console logging, otherwise, the console logging is turned off, all events will be logged into the provided file. Args: level: the log level, one of logging.DEBUG, logging.INFO, logging.WARNING, logging.Error log_file: the absolute file path for the log. file_size: file size in MB unit file_count: how many backup files leaved in disk Returns: None \"\"\" assert file_count > 0 assert file_size > 0 from logging import handlers formatter = logging . Formatter ( \" %(asctime)s %(levelname)-1.1s %(filename)s : %(lineno)s | %(message)s \" ) _logger = logging . getLogger () _logger . setLevel ( level ) if log_file is None : console = logging . StreamHandler () console . setFormatter ( formatter ) _logger . addHandler ( console ) else : file_dir = os . path . dirname ( log_file ) os . makedirs ( file_dir , exist_ok = True ) rotating_file = handlers . RotatingFileHandler ( log_file , maxBytes = 1024 * 1024 * file_size , backupCount = file_count ) rotating_file . setFormatter ( formatter ) _logger . addHandler ( rotating_file ) init ( local_cfg_path = None , dump_on_change = True , strict = False ) \u00b6 create cfg object. Parameters: Name Type Description Default local_cfg_path str the directory name where your configuration files exist None dump_on_change if configuration is updated, whether or not to dump them into log file True Source code in cfg4py/core.py def init ( local_cfg_path : str = None , dump_on_change = True , strict = False ): \"\"\" create cfg object. Args: local_cfg_path: the directory name where your configuration files exist dump_on_change: if configuration is updated, whether or not to dump them into log file Returns: \"\"\" global _local_config_dir , _dump_on_change , _remote_fetcher , _local_observer global _cfg_obj , _cfg_local , _cfg_remote global _strict _strict = strict _dump_on_change = dump_on_change if local_cfg_path : _local_config_dir = os . path . expanduser ( local_cfg_path ) _cfg_local = _load_from_local_file () update_config ( _mixin ( _cfg_remote , _cfg_local )) try : # handle local configuration file change, this may not be available on some platform, like apple m1 _local_observer = Observer () _local_observer . schedule ( LocalConfigChangeHandler (), _local_config_dir , recursive = False ) _local_observer . start () except Exception as e : logger . exception ( e ) logger . warning ( \"failed to watch file changes. Hot-reload is not available\" ) return _cfg_obj","title":"modules"},{"location":"api/#cfg4py.cli","text":"","title":"cli"},{"location":"api/#cfg4py.cli.Command","text":"Source code in cfg4py/cli.py class Command : def __init__ ( self ): self . resource_path = os . path . normpath ( os . path . join ( os . path . dirname ( __file__ ), \"resources/\" ) ) self . yaml = YAML ( typ = \"safe\" ) # default, if not specfied, is 'rt' (round-trip) self . yaml . default_flow_style = False with open ( os . path . join ( self . resource_path , \"template.yaml\" ), \"r\" , encoding = \"utf-8\" ) as f : self . templates = self . yaml . load ( f ) self . transformed = self . _transform () def build ( self , config_dir : str ): \"\"\"Compile configuration files into python script, which is used by IDE's auto-complete function Args: config_dir: The folder where your configuration files located Returns: \"\"\" if not os . path . exists ( config_dir ): print ( f \"path { config_dir } not exists\" ) sys . exit ( - 1 ) count = 0 for f in os . listdir ( config_dir ): if ( f . startswith ( \"default\" ) or f . startswith ( \"dev\" ) or f . startswith ( \"test\" ) or f . startswith ( \"production\" ) ): print ( f \"found { f } \" ) count += 1 if count > 0 : print ( f \" { count } files found in total\" ) else : print ( \"the folder contains no valid configuration files\" ) sys . exit ( - 1 ) try : init ( config_dir ) sys . path . insert ( 0 , config_dir ) from schema import Config # type: ignore # noqa output_file = f \" { os . path . join ( config_dir , 'schema' ) } \" msg = f \"Config file is built with success and saved at { output_file } \" print ( msg ) except Exception as e : # pragma: no cover logging . exception ( e ) print ( \"Config file built failure.\" ) def _choose_dest_dir ( self , dst ): if dst is None : dst = input ( \"Where should I save configuration files? \\n \" ) if os . path . exists ( dst ): for f in os . listdir ( dst ): msg = f \"The folder already contains { f } , please choose clean one.\" if f in [ \"defaults.yaml\" , \"dev.yaml\" , \"test.yaml\" , \"production.yaml\" ]: print ( msg ) return None return dst else : create = input ( \"Path not exists, create('Q' to exit)? [Y/n]\" ) if create . upper () == \"Y\" : os . makedirs ( dst , exist_ok = True ) return dst elif create . upper () == \"Q\" : sys . exit ( - 1 ) else : return None def scaffold ( self , dst : Optional [ str ]): \"\"\"Creates initial configuration files based on our choices. Args: dst: Returns: \"\"\" print ( \"Creating a configuration boilerplate:\" ) dst = self . _choose_dest_dir ( dst ) while dst is None : dst = self . _choose_dest_dir ( dst ) yaml = YAML ( typ = \"safe\" ) # default, if not specfied, is 'rt' (round-trip) with open ( os . path . join ( self . resource_path , \"template.yaml\" ), \"r\" , encoding = \"utf-8\" ) as f : templates = yaml . load ( f ) print ( \"Which flavors do you want?\" ) print ( \"-\" * 20 ) prompt = \"\"\" 0 - console + rotating file logging 10 - redis/redis-py (gh://andymccurdy/redis-py) 11 - redis/aioredis (gh://aio-libs/aioredis) 20 - mysql/PyMySQL (gh://PyMySQL/PyMySQL) 30 - postgres/asyncpg (gh://MagicStack/asyncpg) 31 - postgres/psycopg2 (gh://psycopg/psycopg2) 40 - mq/pika (gh://pika/pika) 50 - mongodb/pymongo (gh://mongodb/mongo-python-driver) \"\"\" print ( prompt ) chooses = input ( \"Please choose flavors by index, separated each by a comma(,): \\n \" ) flavors = {} mapping = { \"0\" : \"logging\" , \"1\" : \"redis\" , \"2\" : \"mysql\" , \"3\" : \"postgres\" , \"4\" : \"mq\" , \"5\" : \"mongodb\" , } for index in chooses . strip ( \" \" ) . split ( \",\" ): if index == \"0\" : flavors [ \"logging\" ] = templates [ \"logging\" ] continue try : major = mapping [ index [ 0 ]] minor = int ( index [ 1 ]) flavors [ major ] = list ( templates [ major ][ minor ] . values ())[ 0 ] except ( ValueError , KeyError ): print ( f \"Wrong index { index } , skipped.\" ) continue with open ( os . path . join ( dst , \"defaults.yaml\" ), \"w\" , encoding = \"utf-8\" ) as f : f . writelines ( \"#auto generated by Cfg4Py: https://github.com/jieyu-tech/cfg4py \\n \" ) yaml . dump ( flavors , f ) print ( f \"Cfg4Py has generated the following files under { dst } :\" ) print ( \"defaults.yaml\" ) for name in [ \"dev.yaml\" , \"test.yaml\" , \"production.yaml\" ]: with open ( os . path . join ( dst , name ), \"w\" , encoding = \"utf8\" ) as f : f . writelines ( \"#auto generated by Cfg4Py: https://github.com/jieyu-tech/cfg4py \\n \" ) print ( name ) with open ( os . path . join ( dst , \"defaults.yaml\" ), \"r\" , encoding = \"utf-8\" ) as f : print ( \"Content in defaults.yaml\" ) for line in f . readlines (): print ( line . replace ( \" \\n \" , \"\" )) def _show_supported_config ( self ): print ( \"Support the following configurations:\" ) for key in self . templates . keys (): item = self . templates . get ( key ) if isinstance ( item , dict ): print ( f \" { key } \" ) elif isinstance ( item , list ): sub_keys = [] for sub_item in item : sub_keys . append ( f \" { key } / { list ( sub_item . keys ())[ 0 ] } \" ) print ( f \" { key } : { ', ' . join ( sub_keys ) } \" ) def _transform ( self ): transformed = {} for key in self . templates : if isinstance ( self . templates [ key ], dict ): transformed [ key ] = self . templates [ key ] elif isinstance ( self . templates [ key ], list ): for item in self . templates [ key ]: item_key = list ( item . keys ())[ 0 ] transformed [ f \" { key } / { item_key } \" ] = item return transformed def hint ( self , what : str = None , usage : bool = False ): \"\"\"show a cheat sheet for configurations. for example: cfg4py hint mysql this will print how to configure PyMySQL :param what :param usage \"\"\" if what is None or ( ( what not in self . templates ) and what not in self . transformed ): return self . _show_supported_config () usage_key = f \" { what } _usage\" if usage_key in self . templates and usage : print ( \"Usage:\" , self . templates . get ( usage_key )) if what in self . templates : self . yaml . dump ( self . templates [ what ], sys . stdout ) if usage_key in self . transformed and usage : print ( \"Usage:\" , self . transformed . get ( usage_key )) if what in self . transformed : self . yaml . dump ( self . transformed [ what ], sys . stdout ) def set_server_role ( self ): print ( \"please add the following line into your .bashrc: \\n \" ) print ( f \"export { envar } =DEV \\n \" ) msg = \"You need to change DEV to TEST | PRODUCTION according to its actual role \\ accordingly\" print ( msg ) def version ( self ): from cfg4py import __version__ print ( \"Easy config module support code complete, cascading design and apative deployment\" ) print ( f \"version: { __version__ } \" )","title":"Command"},{"location":"api/#cfg4py.cli.Command.build","text":"Compile configuration files into python script, which is used by IDE's auto-complete function Parameters: Name Type Description Default config_dir str The folder where your configuration files located required Source code in cfg4py/cli.py def build ( self , config_dir : str ): \"\"\"Compile configuration files into python script, which is used by IDE's auto-complete function Args: config_dir: The folder where your configuration files located Returns: \"\"\" if not os . path . exists ( config_dir ): print ( f \"path { config_dir } not exists\" ) sys . exit ( - 1 ) count = 0 for f in os . listdir ( config_dir ): if ( f . startswith ( \"default\" ) or f . startswith ( \"dev\" ) or f . startswith ( \"test\" ) or f . startswith ( \"production\" ) ): print ( f \"found { f } \" ) count += 1 if count > 0 : print ( f \" { count } files found in total\" ) else : print ( \"the folder contains no valid configuration files\" ) sys . exit ( - 1 ) try : init ( config_dir ) sys . path . insert ( 0 , config_dir ) from schema import Config # type: ignore # noqa output_file = f \" { os . path . join ( config_dir , 'schema' ) } \" msg = f \"Config file is built with success and saved at { output_file } \" print ( msg ) except Exception as e : # pragma: no cover logging . exception ( e ) print ( \"Config file built failure.\" )","title":"build()"},{"location":"api/#cfg4py.cli.Command.hint","text":"show a cheat sheet for configurations. for example: cfg4py hint mysql this will print how to configure PyMySQL :param what :param usage Source code in cfg4py/cli.py def hint ( self , what : str = None , usage : bool = False ): \"\"\"show a cheat sheet for configurations. for example: cfg4py hint mysql this will print how to configure PyMySQL :param what :param usage \"\"\" if what is None or ( ( what not in self . templates ) and what not in self . transformed ): return self . _show_supported_config () usage_key = f \" { what } _usage\" if usage_key in self . templates and usage : print ( \"Usage:\" , self . templates . get ( usage_key )) if what in self . templates : self . yaml . dump ( self . templates [ what ], sys . stdout ) if usage_key in self . transformed and usage : print ( \"Usage:\" , self . transformed . get ( usage_key )) if what in self . transformed : self . yaml . dump ( self . transformed [ what ], sys . stdout )","title":"hint()"},{"location":"api/#cfg4py.cli.Command.scaffold","text":"Creates initial configuration files based on our choices. Parameters: Name Type Description Default dst Optional[str] required Source code in cfg4py/cli.py def scaffold ( self , dst : Optional [ str ]): \"\"\"Creates initial configuration files based on our choices. Args: dst: Returns: \"\"\" print ( \"Creating a configuration boilerplate:\" ) dst = self . _choose_dest_dir ( dst ) while dst is None : dst = self . _choose_dest_dir ( dst ) yaml = YAML ( typ = \"safe\" ) # default, if not specfied, is 'rt' (round-trip) with open ( os . path . join ( self . resource_path , \"template.yaml\" ), \"r\" , encoding = \"utf-8\" ) as f : templates = yaml . load ( f ) print ( \"Which flavors do you want?\" ) print ( \"-\" * 20 ) prompt = \"\"\" 0 - console + rotating file logging 10 - redis/redis-py (gh://andymccurdy/redis-py) 11 - redis/aioredis (gh://aio-libs/aioredis) 20 - mysql/PyMySQL (gh://PyMySQL/PyMySQL) 30 - postgres/asyncpg (gh://MagicStack/asyncpg) 31 - postgres/psycopg2 (gh://psycopg/psycopg2) 40 - mq/pika (gh://pika/pika) 50 - mongodb/pymongo (gh://mongodb/mongo-python-driver) \"\"\" print ( prompt ) chooses = input ( \"Please choose flavors by index, separated each by a comma(,): \\n \" ) flavors = {} mapping = { \"0\" : \"logging\" , \"1\" : \"redis\" , \"2\" : \"mysql\" , \"3\" : \"postgres\" , \"4\" : \"mq\" , \"5\" : \"mongodb\" , } for index in chooses . strip ( \" \" ) . split ( \",\" ): if index == \"0\" : flavors [ \"logging\" ] = templates [ \"logging\" ] continue try : major = mapping [ index [ 0 ]] minor = int ( index [ 1 ]) flavors [ major ] = list ( templates [ major ][ minor ] . values ())[ 0 ] except ( ValueError , KeyError ): print ( f \"Wrong index { index } , skipped.\" ) continue with open ( os . path . join ( dst , \"defaults.yaml\" ), \"w\" , encoding = \"utf-8\" ) as f : f . writelines ( \"#auto generated by Cfg4Py: https://github.com/jieyu-tech/cfg4py \\n \" ) yaml . dump ( flavors , f ) print ( f \"Cfg4Py has generated the following files under { dst } :\" ) print ( \"defaults.yaml\" ) for name in [ \"dev.yaml\" , \"test.yaml\" , \"production.yaml\" ]: with open ( os . path . join ( dst , name ), \"w\" , encoding = \"utf8\" ) as f : f . writelines ( \"#auto generated by Cfg4Py: https://github.com/jieyu-tech/cfg4py \\n \" ) print ( name ) with open ( os . path . join ( dst , \"defaults.yaml\" ), \"r\" , encoding = \"utf-8\" ) as f : print ( \"Content in defaults.yaml\" ) for line in f . readlines (): print ( line . replace ( \" \\n \" , \"\" ))","title":"scaffold()"},{"location":"api/#cfg4py.core","text":"Main module.","title":"core"},{"location":"api/#cfg4py.core.LocalConfigChangeHandler","text":"Source code in cfg4py/core.py class LocalConfigChangeHandler ( FileSystemEventHandler ): def dispatch ( self , event ): if not isinstance ( event , FileModifiedEvent ): return ext = os . path . splitext ( event . src_path ) if ext in [ \".yml\" , \".yaml\" ]: _load_from_local_file ()","title":"LocalConfigChangeHandler"},{"location":"api/#cfg4py.core.LocalConfigChangeHandler.dispatch","text":"Dispatches events to the appropriate methods. :param event: The event object representing the file system event. :type event: :class: FileSystemEvent Source code in cfg4py/core.py def dispatch ( self , event ): if not isinstance ( event , FileModifiedEvent ): return ext = os . path . splitext ( event . src_path ) if ext in [ \".yml\" , \".yaml\" ]: _load_from_local_file ()","title":"dispatch()"},{"location":"api/#cfg4py.core.config_remote_fetcher","text":"config a remote configuration fetcher, which will pull the settings on every refresh_interval Parameters: Name Type Description Default fetcher RemoteConfigFetcher sub class of RemoteConfigFetcher required interval int how long should cfg4py to pull the configuration from remote 300 Source code in cfg4py/core.py def config_remote_fetcher ( fetcher : RemoteConfigFetcher , interval : int = 300 ): \"\"\" config a remote configuration fetcher, which will pull the settings on every `refresh_interval` Args: fetcher: sub class of `RemoteConfigFetcher` interval: how long should cfg4py to pull the configuration from remote Returns: \"\"\" global _remote_fetcher _remote_fetcher = fetcher _scheduler . add_job ( _refresh , \"interval\" , seconds = interval ) _scheduler . start ()","title":"config_remote_fetcher()"},{"location":"api/#cfg4py.core.enable_logging","text":"Enable basic log function for the application if log_file is None, then it'll provide console logging, otherwise, the console logging is turned off, all events will be logged into the provided file. Parameters: Name Type Description Default level the log level, one of logging.DEBUG, logging.INFO, logging.WARNING, 20 log_file the absolute file path for the log. None file_size file size in MB unit 10 file_count how many backup files leaved in disk 7 Returns: Type Description None Source code in cfg4py/core.py def enable_logging ( level = logging . INFO , log_file = None , file_size = 10 , file_count = 7 ): \"\"\" Enable basic log function for the application if log_file is None, then it'll provide console logging, otherwise, the console logging is turned off, all events will be logged into the provided file. Args: level: the log level, one of logging.DEBUG, logging.INFO, logging.WARNING, logging.Error log_file: the absolute file path for the log. file_size: file size in MB unit file_count: how many backup files leaved in disk Returns: None \"\"\" assert file_count > 0 assert file_size > 0 from logging import handlers formatter = logging . Formatter ( \" %(asctime)s %(levelname)-1.1s %(filename)s : %(lineno)s | %(message)s \" ) _logger = logging . getLogger () _logger . setLevel ( level ) if log_file is None : console = logging . StreamHandler () console . setFormatter ( formatter ) _logger . addHandler ( console ) else : file_dir = os . path . dirname ( log_file ) os . makedirs ( file_dir , exist_ok = True ) rotating_file = handlers . RotatingFileHandler ( log_file , maxBytes = 1024 * 1024 * file_size , backupCount = file_count ) rotating_file . setFormatter ( formatter ) _logger . addHandler ( rotating_file )","title":"enable_logging()"},{"location":"api/#cfg4py.core.init","text":"create cfg object. Parameters: Name Type Description Default local_cfg_path str the directory name where your configuration files exist None dump_on_change if configuration is updated, whether or not to dump them into log file True Source code in cfg4py/core.py def init ( local_cfg_path : str = None , dump_on_change = True , strict = False ): \"\"\" create cfg object. Args: local_cfg_path: the directory name where your configuration files exist dump_on_change: if configuration is updated, whether or not to dump them into log file Returns: \"\"\" global _local_config_dir , _dump_on_change , _remote_fetcher , _local_observer global _cfg_obj , _cfg_local , _cfg_remote global _strict _strict = strict _dump_on_change = dump_on_change if local_cfg_path : _local_config_dir = os . path . expanduser ( local_cfg_path ) _cfg_local = _load_from_local_file () update_config ( _mixin ( _cfg_remote , _cfg_local )) try : # handle local configuration file change, this may not be available on some platform, like apple m1 _local_observer = Observer () _local_observer . schedule ( LocalConfigChangeHandler (), _local_config_dir , recursive = False ) _local_observer . start () except Exception as e : logger . exception ( e ) logger . warning ( \"failed to watch file changes. Hot-reload is not available\" ) return _cfg_obj","title":"init()"},{"location":"authors/","text":"Credits \u00b6 Development Lead \u00b6 Aaron Yang aaron_yang@jieyu.ai Contributors \u00b6 None yet. Why not be the first?","title":"authors"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#development-lead","text":"Aaron Yang aaron_yang@jieyu.ai","title":"Development Lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/zillionare/cfg4py/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 cfg4py could always use more documentation, whether as part of the official cfg4py docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/zillionare/cfg4py/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up cfg4py for local development. Fork the cfg4py repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/cfg4py.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/zillionare/cfg4py/actions and make sure that the tests pass for all supported Python versions. Tips``` \u00b6 1 $ pytest tests.test_cfg4py ```To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Github Actions will then deploy to PyPI if tests pass.","title":"contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/zillionare/cfg4py/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"cfg4py could always use more documentation, whether as part of the official cfg4py docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/zillionare/cfg4py/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up cfg4py for local development. Fork the cfg4py repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/cfg4py.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/zillionare/cfg4py/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"1 $ pytest tests.test_cfg4py ```To run a subset of tests.","title":"Tips```"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Github Actions will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"faq/","text":"FAQ \u00b6 What is schema.py? It's generated for code completion. It's safe to keep it in both development environment and release package. Don't try to instantiate it (an TypeError will raise to prevent from instantiate it), you should only use it for typing annotation. Why after upgrade to 0.9.0, cfg4py doesn't work as before? v0.9 introduced strict mode, which is False by default. When cfg4py is initialized with strict = True , cfg4py works only if cfg4py_server_role is set; if it's non-strict mode, cfg4py works with cfg4py_server_role is not set. So if you've used cfg4py for a while and it worked before v0.9, then you need to modify your code where it initialize cfg4py as: 1 2 3 4 import cfg4py # strict is an added param cfg4py . init ( 'path_to_config_dir_as_before' , strict = True ) if you don't specify strict = True , cfg4py still works, but it will NOT read config under the name 'dev.yaml', 'test.yaml' or 'production.yaml' Why cfg.logging acts like dict? Because cfg.logging`` is a dict. cfg.logging` is provided since 0.9.3, in case one may need it, for example, get the log file location. However, logging settings may contains key that is python's reserved word, thus it's not possible to convert it into python's object (It's not allowed to use python's reserved word as object's member)","title":"faq"},{"location":"faq/#faq","text":"What is schema.py? It's generated for code completion. It's safe to keep it in both development environment and release package. Don't try to instantiate it (an TypeError will raise to prevent from instantiate it), you should only use it for typing annotation. Why after upgrade to 0.9.0, cfg4py doesn't work as before? v0.9 introduced strict mode, which is False by default. When cfg4py is initialized with strict = True , cfg4py works only if cfg4py_server_role is set; if it's non-strict mode, cfg4py works with cfg4py_server_role is not set. So if you've used cfg4py for a while and it worked before v0.9, then you need to modify your code where it initialize cfg4py as: 1 2 3 4 import cfg4py # strict is an added param cfg4py . init ( 'path_to_config_dir_as_before' , strict = True ) if you don't specify strict = True , cfg4py still works, but it will NOT read config under the name 'dev.yaml', 'test.yaml' or 'production.yaml' Why cfg.logging acts like dict? Because cfg.logging`` is a dict. cfg.logging` is provided since 0.9.3, in case one may need it, for example, get the log file location. However, logging settings may contains key that is python's reserved word, thus it's not possible to convert it into python's object (It's not allowed to use python's reserved word as object's member)","title":"FAQ"},{"location":"history/","text":"History \u00b6 Info (#{number}) means an issue of this project. You may check details of the issue by visiting https://github.com/zillionare/cfg4py/issues/ {number} 0.9.4 (2022-08-25) \u00b6 lock apscheduler version to 3.9.1. APScheduler 4.0 has been refactored thus cause importing error. 0.9.3 (2022-06-03) \u00b6 on apple m1, it's not able to watch file changes, and cause cfg4py fail. This revision will disable hot-reload in such scenario and user can still use all other functions of cfg4py. remove support for python 3.6 since it's out of service, and opt 3.10, 3.11 in (#4) log settings are now available by cfg.logging . 0.9.2 (2021-12-17) \u00b6 (#1) hot-reload will now only react to configuration files's change. 0.9.0 (2020-12-03) \u00b6 add strict mode: default is non-strict mode, which allows you run cfg4py without set environment variable cfg4py_server_role this is a break change. If you've used cfg4py in your project and it worked well, after upgrade to 0.9.0, you have to modify your init code as this: 1 cfg4py . init ( 'path_to_config_dir' , strict = True ) see more in usage and FAQ document 0.8.0 (2020-11-22) \u00b6 rename cfg4py_auto_gen.py to schema.py 0.7.0 (2020-10-31) \u00b6 support environment macro 0.5.0 (2020-04-30) \u00b6 add command hint, set_server_role export envar add pip source, conda source 0.1.0 (2020-04-06) \u00b6 First release on PyPI.","title":"history"},{"location":"history/#history","text":"Info (#{number}) means an issue of this project. You may check details of the issue by visiting https://github.com/zillionare/cfg4py/issues/ {number}","title":"History"},{"location":"history/#094-2022-08-25","text":"lock apscheduler version to 3.9.1. APScheduler 4.0 has been refactored thus cause importing error.","title":"0.9.4 (2022-08-25)"},{"location":"history/#093-2022-06-03","text":"on apple m1, it's not able to watch file changes, and cause cfg4py fail. This revision will disable hot-reload in such scenario and user can still use all other functions of cfg4py. remove support for python 3.6 since it's out of service, and opt 3.10, 3.11 in (#4) log settings are now available by cfg.logging .","title":"0.9.3 (2022-06-03)"},{"location":"history/#092-2021-12-17","text":"(#1) hot-reload will now only react to configuration files's change.","title":"0.9.2 (2021-12-17)"},{"location":"history/#090-2020-12-03","text":"add strict mode: default is non-strict mode, which allows you run cfg4py without set environment variable cfg4py_server_role this is a break change. If you've used cfg4py in your project and it worked well, after upgrade to 0.9.0, you have to modify your init code as this: 1 cfg4py . init ( 'path_to_config_dir' , strict = True ) see more in usage and FAQ document","title":"0.9.0 (2020-12-03)"},{"location":"history/#080-2020-11-22","text":"rename cfg4py_auto_gen.py to schema.py","title":"0.8.0 (2020-11-22)"},{"location":"history/#070-2020-10-31","text":"support environment macro","title":"0.7.0 (2020-10-31)"},{"location":"history/#050-2020-04-30","text":"add command hint, set_server_role export envar add pip source, conda source","title":"0.5.0 (2020-04-30)"},{"location":"history/#010-2020-04-06","text":"First release on PyPI.","title":"0.1.0 (2020-04-06)"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install Cfg4Py, run this command in your terminal: 1 $ pip install cfg4py This is the preferred method to install Cfg4Py, as it will always install the most recent stable release. From sources \u00b6 The sources for Cfg4Py can be downloaded from the Github repo You can either clone the public repository: 1 $ git clone Or download the tarball 1 $ curl -OJL https://github.com/zillionare/cfg4py/tarball/master Once you have a copy of the source, you can install it with: 1 $ python setup.py install","title":"installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install Cfg4Py, run this command in your terminal: 1 $ pip install cfg4py This is the preferred method to install Cfg4Py, as it will always install the most recent stable release.","title":"Stable release"},{"location":"installation/#from-sources","text":"The sources for Cfg4Py can be downloaded from the Github repo You can either clone the public repository: 1 $ git clone Or download the tarball 1 $ curl -OJL https://github.com/zillionare/cfg4py/tarball/master Once you have a copy of the source, you can install it with: 1 $ python setup.py install","title":"From sources"},{"location":"usage/","text":"Quick Guide \u00b6 To use Cfg4Py in a project: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import cfg4py # create config object cfg = cfg4py . init ( path_to_config_dir ) # then refer to settings by cfg's properties # given the following yaml settings (filename: defaults.yaml) under path_to_config_dir # services: # redis: # host: localhost # you can access settings by '.' print ( cfg . services . redis . host ) # you CANNOT access settings like this way (this will raise exceptions): print ( cfg [ \"services\" ]) Exhausted Guide \u00b6 Step 1. \u00b6 Use Cfg4Py tool to generate configuration templates: 1 cfg4py scaffold The output is: You may need modify settings according to your enviroment. Step 2. \u00b6 Build config class, and import it into your project: 1 cfg4py build /path/to/your/config/dir 1 2 3 4 5 6 7 8 9 10 from typing import TYPE_CHECKING if TYPE_CHECKING : # make sure that schema is at your $PYTHONPATH from schema import Config import cfg4py cfg : Config = cfg4py . init ( '/path/to/your/config/dir' ) # now you should be able to get auto-complete hint while typing cfg . ? Step 3. \u00b6 cfg4py will take care of setting's change automatically, all you need to do is put correct settings into one of (defaults, dev, test, production) config file. And once you change the settings, it should take effect immediately. To enable cascading config, you can configure a remote source by implemented a subclass of RemoteConfigFetcher . A redis fetcher is provided out-of-box: 1 2 3 4 5 6 7 from cfg4py import RedisConfigFetcher from redis import StrictRedis cfg = cfg4py . int () # since we're using remote config now, so we can omit path param here fetcher = RedisConfigFetcher ( key = \"my_app_config\" ) logger . info ( \"configuring a remote fetcher\" ) cfg4py . config_remote_fetcher ( fetcher , 1 ) The settings in redis under key should be a json string, which can be converted into a dict object. Step 4. \u00b6 Before starting run your application, you should set cfg4py_server_role to any of [DEV,TEST,PRODUCTION] (since 0.9.0, required only if you specified as strict mode). You can run the following command to get the help: 1 cfg4py hint set_server_role Info 1 since 0.9.0, you can skip this step, if you don't need adaptive deployment support. Use cfg4py as a cheat sheet \u00b6 cfg4py does more than a config module, it can be a cheat sheet for many configurations. For example, want to change pip source (usually you'll if you're in china mainland): 1 2 3 4 5 6 7 cfg4py hint pip > - tsinghua: pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple - aliyun: pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ - tencent: pip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simple - douban: pip config set global.index-url http://pypi.douban.com/simple/ for more, explore by yourself by typing cfg4py hint","title":"usage"},{"location":"usage/#quick-guide","text":"To use Cfg4Py in a project: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import cfg4py # create config object cfg = cfg4py . init ( path_to_config_dir ) # then refer to settings by cfg's properties # given the following yaml settings (filename: defaults.yaml) under path_to_config_dir # services: # redis: # host: localhost # you can access settings by '.' print ( cfg . services . redis . host ) # you CANNOT access settings like this way (this will raise exceptions): print ( cfg [ \"services\" ])","title":"Quick Guide"},{"location":"usage/#exhausted-guide","text":"","title":"Exhausted Guide"},{"location":"usage/#step-1","text":"Use Cfg4Py tool to generate configuration templates: 1 cfg4py scaffold The output is: You may need modify settings according to your enviroment.","title":"Step 1."},{"location":"usage/#step-2","text":"Build config class, and import it into your project: 1 cfg4py build /path/to/your/config/dir 1 2 3 4 5 6 7 8 9 10 from typing import TYPE_CHECKING if TYPE_CHECKING : # make sure that schema is at your $PYTHONPATH from schema import Config import cfg4py cfg : Config = cfg4py . init ( '/path/to/your/config/dir' ) # now you should be able to get auto-complete hint while typing cfg . ?","title":"Step 2."},{"location":"usage/#step-3","text":"cfg4py will take care of setting's change automatically, all you need to do is put correct settings into one of (defaults, dev, test, production) config file. And once you change the settings, it should take effect immediately. To enable cascading config, you can configure a remote source by implemented a subclass of RemoteConfigFetcher . A redis fetcher is provided out-of-box: 1 2 3 4 5 6 7 from cfg4py import RedisConfigFetcher from redis import StrictRedis cfg = cfg4py . int () # since we're using remote config now, so we can omit path param here fetcher = RedisConfigFetcher ( key = \"my_app_config\" ) logger . info ( \"configuring a remote fetcher\" ) cfg4py . config_remote_fetcher ( fetcher , 1 ) The settings in redis under key should be a json string, which can be converted into a dict object.","title":"Step 3."},{"location":"usage/#step-4","text":"Before starting run your application, you should set cfg4py_server_role to any of [DEV,TEST,PRODUCTION] (since 0.9.0, required only if you specified as strict mode). You can run the following command to get the help: 1 cfg4py hint set_server_role Info 1 since 0.9.0, you can skip this step, if you don't need adaptive deployment support.","title":"Step 4."},{"location":"usage/#use-cfg4py-as-a-cheat-sheet","text":"cfg4py does more than a config module, it can be a cheat sheet for many configurations. For example, want to change pip source (usually you'll if you're in china mainland): 1 2 3 4 5 6 7 cfg4py hint pip > - tsinghua: pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple - aliyun: pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ - tencent: pip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simple - douban: pip config set global.index-url http://pypi.douban.com/simple/ for more, explore by yourself by typing cfg4py hint","title":"Use cfg4py as a cheat sheet"}]}